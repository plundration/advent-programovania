# Zoznamy

Ke캞쬰 po캜칤ta캜e 캜asto nar치baj칰 s d치tami, ktor칳ch nie je iba jeden kus naraz,
potrebuj칰 ma콘 sp칪sob, ako uklada콘 a spracova콘 ve쬬 d치t rovnak칠ho typu. V
programovac칤ch jazykoch na to sl칰쬴a **zoznamy**. Go m치 2 sp칪soby, ako zoznam
vytvori콘. Pozn치me *statick칠 zoznamy*, lep코ie nazvan칠 *arrays*, ktor칠 obsahuj칰 pevn칳 po캜et
prvkov. O chv칤쬿 sa ale pozrieme aj na *slice*, ktor칠ho po캜et prvkov sa d치
zmeni콘.

## Statick칠 zoznamy

Dajme tomu, 쬰 chceme vytvori콘 zoznam troch prvkov. Vytvor칤me ho nasledovn칳m syntaxom:

```go
// --snip--
  // pr치zny zoznam cel칳ch 캜칤sel o ve쬶osti 3
  var prvy_zoznam [3]int
  // zoznam inicializovan칳 z troch prvkov
  kamarati := [3]string{"dlh칳", "코irok칳", "bystrozrak칳"}
// --snip--
```

Ak chceme prist칰pi콘 k n-t칠mu prvku zoznamu, vyu쬴jeme syntax hranat칳ch z치tvoriek:

```go
// --snip--
  // prvok nula je prvy
  fmt.Println("Prv칳 z kamar치tov sa vol치", kamarati[0])
  
  for i := 0; i < 3; i++ {
    fmt.Println("Kamar치t", i, "sa vol치", kamarati[i])
  }
  
  // prvkom mozeme aj priradovat hodnotu
  kamarati[0] = "kr치tky"
  kamarati[1] = "tenk칳"
  kamarati[2] = "slep칳"

  fmt.Println("Opak dlh칠ho je", kamarati[0])
// --snip--
```

Neexistuje ve쬬 pr칤padov vyu쬴tia zoznamov, ktor칳ch ve쬶os콘 sa ned치 meni콘,
minim치lne v jednom rozmere. Dobr치 spr치va je, 쬰 existuj칰 aj *viacrozmern칠*
zoznamy - ide vpodstate o zoznamy zoznamov. M칪쬰me takto reprezentova콘 napr칤klad
matice, o ktor칳ch si mo쬹o nie캜o potom povieme. Zoznam zoznamov m칪쬰 by콘
napr칤klad aj obr치zok, ktor칳 sa nach치dza v dvojrozmernom priestore, alebo aj
voxelov칳 (kockat칳) 3D model. Viacrozmern칠 zoznamy sa vytv치raj칰 nasledovne:

```go
// --snip--
	//          +-----prvy rozmer
	//          |  +--druhy rozmer
	//          v  v
	var matrix [4][4]int

	matrix[0][0] = 1
	matrix[1][1] = 1
	matrix[2][2] = 1
	matrix[3][3] = 1

	for i := 0; i < 4; i++ {
		for j := 0; j < 4; j++ {
		// \t je tabul치tor
    	// z i-teho zoznamu v zozname vyberame j-ty prvok
			fmt.Print(matrix[i][j], "\t")
		}
		fmt.Println()
	}
// --snip--
```

Viete, ako sme si s쬿bovali, 쬰 sierpinskeho trojuholn칤k sa d치 vykresli콘 ove쬬
jednoduch코ie? Na to n치m pom칪쬰 napr칤klad zoznam hodn칪t `bool` (t칳ch, ktor칠 maj칰
hodnotu iba `true` alebo `false`). Tieto zaberaj칰 iba jeden byte (a d치 sa to
spravi콘 aj tak, aby zaberali iba jeden bit!). Pomocou t칳chto bin치rnych hodn칪t si
zap칤코eme p치rnos콘 캜칤sel v pascalovom trojuholn칤ku:

```go
package main

import "fmt"

func main() {
	const n = 33          // kon코tanta (zoznam mus칤 ma콘 kon코tantn칳 rozmer)
	var values [2][n]bool // zoznam dvoch zoznamov po n prvkoch
	values[0][n/2] = true // chceme zacat s jednym pixelom hore

	for y := 0; y < n/2; y++ {
		// musime osetrit okraje, kedze budeme pouzivat x-1 a x+1
		for x := 1; x < n-1; x++ {
			// potrebujeme zoznamy striedat - raz cerpame z prveho zoznamy a piseme dodruheho,
			// raz naopak. Keby sme to tak nerobili, novy riadok by sme vypocitavali z hodnot
			// toho isteho riadku a doslo by ku katastrofe.
			a := y % 2
			b := (y + 1) % 2
			if values[a][x] {
				fmt.Print("#")
			} else {
				fmt.Print(" ")
			}
			// cislo v dalsom riadku je parne iba ak sa scitaju dve parne alebo dve neparne cisla.
			values[b][x] = values[a][x-1] != values[a][x+1]
		}
		fmt.Println()
	}
}
```

## V칳rezy (slices) a dynamick칠 zoznamy

> takisto si pre캜칤tajte: [A Tour of Go: Arrays and Slices](https://go.dev/tour/moretypes/6)

Po캞me si najprv vytvori콘 `slice` zoznamu. `slice` reprezentuje ist칳 "n치h쬬d" do
zoznamu, ale s치m prvky neobsahuje. Ozna캜uje sa pr치zdnymi hranat칳mi z치tvorkami a
vytv치ra sa syntaxom `[a:b]`

```go
// --snip--
	kamarati := [3]string{"dlh칳", "코irok칳", "bystrozrak칳"}
	
	// nula vratane, dva nevratane (vyhoda: rozdiel hranic je velkost vyrezu)
	prvi_dvaja := kamarati[0:2]
	fmt.Println(prvi_dvaja)
	// dlh칳 코irok칳
	
	prvi_dvaja[1] = "tenk칳"

	fmt.Println(kamarati)
	// dlh칳, tenk칳, bystrozrak칳
// --snip--
```

Mus칤me si naozaj uvedomi콘, 쬰 slice na zoznam iba referuje. Vieme ho teda pou쬴콘
napr칤klad na zjednodu코enie n치코ho programu so sierpinskeho trojuhon칤kom. V코imnite
si, 쬰 hranice `slice`u m칪쬰me vynecha콘: `[:5]` n치m d치 prv칳ch 5 prvkov zoznamu,
`[5:]` n치m d치 v코etky prvky od 5 hore. `[:]` n치m d치 referenciu na cel칳 zoznam:

```go
// --snip--
func main() {
	const n = 33
	var values [2][n]bool
	values[0][n/2] = true
	a := values[0][:]
	b := values[1][:]

	for y := 0; y < n/2; y++ {
		for x := 1; x < n-1; x++ {
			b[x] = a[x-1] != a[x+1]

			if a[x] {
				fmt.Print("#")
			} else {
				fmt.Print(" ")
			}
		}
		a, b = b, a
		fmt.Println()
	}
}
```

D칪le쬴t칳m druhom `slice`u je aj `nil`: nulov치 hodnota. T칰 캜asto uvid칤te ako
mo쬹칰 n치vratov칰 hodnotu funkci칤.

Samotn칳 `slice` ve쬸i n치pomocn칳 nie je. Zauj칤mav치 vlastno콘 `slice`ov ale je ich
dynamick치 zv칛캜코ite쬹os콘. Toto je sp칪sob, ako n치m Go dovo쬿je robi콘 zoznamy o
arbitr치rnej d컄쬶e. Na pridanie prvku do `slice`u pou쬴jeme funkciu `append`. T치
`slice`u naalokuje nov칠 miesto v pam칛ti, ak je potrebn칠:

```go
// --snip--
  // vytvorime prazdny slice
	var kamarati []string
	// do slice-u prid치 nov칳 prvok, ak je mal칳, naalokuje viac pam칛ti
	kamarati = append(kamarati, "dlh칳")
	kamarati = append(kamarati, "코irok칳", "bystrozrak칳")
	// len() ur캜칤 d컄쬶u slice-u
	for i := 0; i < len(kamarati); i++ {
		fmt.Println(kamarati[i])
	}
// --snip--
```

Op칛콘, jednoduch칠 zoznamy jedn칠ho typu prvkov nie s칰 ve쬶치 z치bava. M칪쬰te ulo쬴콘
napr칤klad iba zoznam mien, alebo iba zoznam po캜tov bodov. Ako vytvori콘 jeden
zoznam, kde sa bud칰 nach치dza콘 aj men치, aj po캜ty bodov, si nech치me nanesk칪r.

Po캞me si ale e코te uk치za콘 jeden pr칤klad, v ktorom si vytvor칤me zoznam ovocia a
zeleniny, ktor칰 vlastn칤me. N치코 program by mal na vstupe bra콘 pr칤kazy. To znie
zlo쬴to, ale s Go je to pomerne jednoduch칠. Sk칰sime tento kr치t n치코 program
aj spr치vne rozdeli콘 na funkcie a pou쬴jeme e코te jednu nov칰 vec: rozvetvenie
`switch`, ktor칠 sl칰쬴 na to, aby sme nep칤sali stovky kr치t `if` a `else if`. Aby
sme si ale zjednodu코ili 쬴vot, obmedz칤me sa na polo쬶y s jednoslovn칳m n치zvom:

```go
package main

import "fmt"

func command_add(list []string) []string {
	var nazov string
	fmt.Scan(&nazov)
	list = append(list, nazov)
	return list
}

func command_remove(list []string) []string {
	var index int
	fmt.Scan(&index)
	index = index - 1
	// ak index nepatri do zoznamu, tak nieco je zle
	// index n nepatri do zoznamu o dlzke n, cize pouzijeme >=
	if index < 0 || index >= len(list) {
		fmt.Println("Zl칠 캜칤slo ovocia")
		// pred캜asne ukon캜칤me funkciu
		return list
	}
	// vymenme prvok za posledny v zozname a skratme zoznam o 1
	// rychlejsie ako presuvanie zoznamu
	// pozor, posleny prvok je [len-1]
	list[index] = list[len(list)-1]
	list = list[:len(list)-1]
	return list
}

func command_print(list []string) {
	for i := 0; i < len(list); i++ {
		// formatovany vystup, aby to bolo pekne: %d znamena cislo, %s znamena string, \n je novy riadok, lebo printf ho normalne nedava
		fmt.Printf("%d. %s\n", i+1, list[i])
	}
}

func main() {
	var ovocie []string

	for {
		var command string
		fmt.Scan(&command)
		switch command {
		case "pridaj":
			ovocie = command_add(ovocie)
		case "odstran":
			ovocie = command_remove(ovocie)
		case "vypis":
			command_print(ovocie)
		case "koniec":
			return // ukonci funkciu main
		default:
			fmt.Println("tak칳to pr칤kaz nepozn치m")
		}
	}
}
```

Vid칤te, 쬰 sme pou쬴li dos콘 ve쬬 nov칳ch funkci칤 jazyka Go. Ak si nie캜칤m nie ste
ist칤, k쬿dne si to vygooglujte. Program치tori to robia 캜asto 游땔

## Array vs Slice

Mo쬹o ste teraz zm칛ten칤, kedy vyu쬴콘 zoznamy a kedy `slice`y. Trik je
jednoduch칳: Ke캞 chcete d치ta roz코irova콘 pomocou `append`, pou쮂셨ajte `slice`.
Ke캞 d치ta dost치vate ako argument funckie, nastavte typ argumentu na `slice`. Ke캞
viete d컄쬶u zoznamu, alebo r치tate s t칳m, 쬰 nebude 캜asto zv칛캜코ovan칳, pou쬴te
`array`.

Pri pou쬴t칤 funkcie `append` sa naalokuje nov칠 miesto v pam칛ti, ktor칠 sa
nach치dza mimo na코ej funkcie, v takzvanej hromade pam칛te, spr치vne zvanej
**Heap**. D치ta v tejto hromade pam칛te sa daj칰 odstra켿ova콘, prid치va콘, zmen코ova콘
a zv칛캜코ova콘. Probl칠m ale je, 쬰 zv칛캜코enie zoznamu 캜asto trv치 tak dlho, ko쬶o
je v zozname prvkov, lebo d치ta sa na heape musia presun칰콘 na nov칠 miesto, kde
maj칰 dos콘 priestoru. Preto je niekedy lep코ie pou쬴콘 `array`, ktor칳 sa nach치dza
v pam칛ti zvanej **Stack**, v ktorej sa nach치dzaj칰 napr칤klad aj premenn칠 funkci칤.
Stack je ve쬸i r칳chly, ale ned치 sa na 켿om v칪bec meni콘 ve쬶os콘 d치t, iba ich
obsah.

E코te jeden trik: Ak chcete vytvori콘 pr치zdny zoznam 캜isto na Heap-e o n prvkoch,
m칪쬰te pou쬴콘 funkciu `make`:

```go
  var same_nuly = make([]int, 10) // 10 nul
```

## E코te jedna men코ia vec, ktor치 sa v치m hod칤 k rie코eniu 칰lohy

V 칰lohe budete pracova콘 s cyklami. V Go existuj칰 코peci치lne pr칤kazy, ktor칠 cyklus
vedia pred캜asne ukon캜i콘. Sk칰sme zo vstupu pre캜칤ta콘 maxim치lne 5 slov, ale ak je
jedno z nich `koniec`, tak ukon캜칤me hne캞 a zoznam nech치me krat코칤. Na to n치m
posl칰쬴 `break`:

```go
// --snip--
	var zoznam []string

	for i := 0; i < 5; i++ {
		var data string
		fmt.Scan(&data)
		if data == "koniec" {
			break
		}
		zoznam = append(zoznam, data)
	}

	fmt.Println(zoznam)
// --snip--
```

Vedeli ste, 쬰 m칪쬰te urobi콘 `slice` zo string-u? Sk칰sme do zoznamu nezap칤sa콘
slov치, ktor칠 za캜칤naj칰 na `a`. Na to n치m posl칰쬴 napr칤klad aj `continue`:

```go
	var zoznam []string

	for i := 0; i < 5; i++ {
		var data string
		fmt.Scan(&data)
		if data[:1] == "a" {
			continue
		}
		zoznam = append(zoznam, data)
	}

	fmt.Println(zoznam)
```

Vstup a v칳stup tohoto k칩du:

```
adam ma velmi rad ananas
[ma velmi rad]
```

V칳hoda `break`, `continue` a aj `return`, ktor칠 v코etky pred캜asne nie캜o ukon캜uj칰,
je t치, 쬰 nemus칤me veci zbyto캜ne vklada콘 do podmienok a ma콘 k칩d posunut칳 o mnoho
tabul치ci칤. Spr치vni program치tori rozde쬿j칰 k칩d do mal칳ch funkci칤, kde m치 ka쬯치
jasn칳 v칳znam a jej obsah nepresahuje 3 a 4 vnoren칠 칰rovne ku캜erav칳ch z치tvoriek.
K칩d je tak ove쬬 preh쬬dnej코칤.

## Zadanie

Vytvore funkciu, ktor치 zotriedi prvky v zozname. In코pirujte sa napr칤klad
[Zoznamom triediacich algoritmov na wikip칠dii](https://en.wikipedia.org/wiki/Sorting_algorithm#Comparison_of_algorithms). Ako vstup vezmite `[]int` (캜i쬰
slice cel칳ch 캜칤sel) a vr치콘te rovnak칳 typ.
