# Errory v Go

Minule sme si spomÃ­nali niekoÄ¾ko vyuÅ¾itÃ­ `interface`ov v Go. Ako jeden znÃ¡my
`interface` sme si predstavili `Stringer`. Jeden veÄ¾mi dÃ´leÅ¾itÃ½ `interface` je
ale aj `Error`, ktorÃ©ho vÃ½znam je asi jasnÃ½. Error obsahuje jedinÃº funkciu,
ktorÃ¡ vracia string obsahujÃºci hlÃ¡senie chyby:

```go
type error interface {
    Error() string
}
```

SkÃºsme si vytvoriÅ¥ funkciu, ktorÃ¡ vrÃ¡ti nÃ¡Å¡ vlastnÃ½ druh `error`u:

```go
// --snip--
type divisionError struct {
	number int
}

func (e *divisionError) Error() string {
	return fmt.Sprint(e.number, " nie je deliteÄ¾nÃ© dvoma!")
}

func divide(x int) (int, error) {
	if x%2 != 0 {
		return 0, &divisionError{number: x}
	}
	return x / 2, nil
}

func main() {
	cislo, err := divide(5)
	if err != nil {
		fmt.Println("Chyba:", err)
		return
	}
	fmt.Println(cislo)
}
```

# SÃºbory

Errory sÃº super, keÄ pouÅ¾Ã­vame nejakÃº kniÅ¾nicu, ktorÃ¡ za nÃ¡s robÃ­ operÃ¡cie,
ktorÃ© mÃ´Å¾u, alebo moÅ¾no aj zvyknÃº, zlyhaÅ¥. Jeden z prÃ­kladov pouÅ¾itia errorov
je otvÃ¡ranie a ÄÃ­tanie sÃºborov. A takto pekne premostÃ­me na ÄalÅ¡iu tÃ©mu.

Ak chceme naÅ¡e dÃ¡ta v programe uchovaÅ¥ aj keÄ sa zavrie, potrebujeme pouÅ¾iÅ¥
sÃºbor. O tom, Äo je sÃºbor, mÃ¡te moÅ¾no uÅ¾ pribliÅ¾nÃº predstavu, ale poÄme si ho
skutoÄne zadefinovaÅ¥: SÃºbor je vyhradenÃ© (nie nutne sÃºvislÃ©) miesto na disku,
ku ktorÃ©mu vieme pristÃºpiÅ¥ pomocou "cesty" po stromovej Å¡truktÃºre prieÄnikov.
SÃºbory sa nachÃ¡dzajÃº v Å¡peciÃ¡lnej dÃ¡tovej Å¡truktÃºre, ktorÃ¡ sa volÃ¡ file system.
Ten nÃ¡m dovoÄ¾uje rozdeliÅ¥ sÃºvislÃ© pole pamÃ¤te (disk) na pomenovanÃ© Ãºseky dÃ¡t.
KeÄÅ¾e filesystem je zloÅ¾itÃ¡ vec a chceme, aby ho kaÅ¾dÃ½ program pouÅ¾Ã­val rovnako,
tÃ¡to dÃ¡tovÃ¡ Å¡truktÃºra je vÅ¾dy spravovanÃ¡ operaÄnÃ½m systÃ©mom (aÅ¾ na prÃ­pady, kedy
to tak nie je :D). KeÄ chceme vytvoriÅ¥ sÃºbor, Äi prieÄinok, alebo z neho ÄÃ­taÅ¥,
Äi pÃ­saÅ¥, musÃ­me to vykomunikovaÅ¥ s operaÄnÃ½m systÃ©mom. OperaÄnÃ½ systÃ©m potom
rozhodne, Äi k sÃºboru vÃ´bec mÃ¡me prÃ­stup, a ako sÃºbor na disku rozloÅ¾Ã­. TÃºto
Å¥aÅ¾kÃº prÃ¡cu komunikÃ¡cie s operaÄnÃ½m systÃ©mom, ktorÃ¡ sa dÃ¡ robiÅ¥ aj ruÄne, za nÃ¡s
robÃ­ kniÅ¾nica `os` jazyka Go.

Postup prÃ¡ce so sÃºborom je nasledovnÃ½: SÃºbor musÃ­me najprv otvoriÅ¥. Takto
operaÄnÃ©mu ssytÃ©mu povieme, Å¾e s nÃ­m budeme pracovaÅ¥ a on nÃ¡m vytvorÃ­ "kurzor"
na ÄÃ­tanie v tomto sÃºbore. Potom pomocou funkciÃ­ vyuÅ¾Ã­vajÃºcich systÃ©movÃ½ prÃ­kaz
`read` zo sÃºboru ÄÃ­tame byty, priÄom sa tento "kurzor" posÃºva, aÅ¾ kÃ½m nedÃ´jde na
koniec a nedostaneme error. Okrem obyÄajnÃ©ho `read`u sa v niektorÃ½ch sÃºboroch dÃ¡
nastaviÅ¥ aj poloha tohoto "kurzora", ale do takÃ½ch detailov zachÃ¡dzaÅ¥ nebudeme.
Nakoniec potrebujeme sÃºbor vÅ¾dy zavrieÅ¥, aby operaÄnÃ½ systÃ©m uloÅ¾il prÃ­padnÃ©
neuloÅ¾enÃ© zmeny do disku a uvoÄ¾nil pamÃ¤Å¥.

SkÃºsme preÄÃ­taÅ¥ byty z nejakÃ©ho sÃºboru:

```go
package main

import (
	"fmt"
	"os"
)

func main() {
	file, err := os.Open("test.txt")
	if err != nil {
		fmt.Println("nastala chyba!")
		return
	}

	for i := 0; ; i++ {
		var data [1]byte
		// n je pocet precitanych bytov, err je error
		n, err := file.Read(data[:])
		if err != nil {
			break
		}
		if n == 0 {
			continue
		}
		fmt.Println("byte ÄÃ­slo", i, "je", data[0])
	}
}
```

VÃ½stup programu je nasledovnÃ½:

```
byte ÄÃ­slo 0 je 68
byte ÄÃ­slo 1 je 111
byte ÄÃ­slo 2 je 98
byte ÄÃ­slo 3 je 114
byte ÄÃ­slo 4 je 195
byte ÄÃ­slo 5 je 189
byte ÄÃ­slo 6 je 32
byte ÄÃ­slo 7 je 100
byte ÄÃ­slo 8 je 101
byte ÄÃ­slo 9 je 197
byte ÄÃ­slo 10 je 136
byte ÄÃ­slo 11 je 33
byte ÄÃ­slo 12 je 10
```

ÄŒo tieto ÄÃ­sla znamenajÃº si povieme o chvÃ­Ä¾u, ale zatiaÄ¾ nÃ¡m staÄÃ­ vedieÅ¥, Å¾e
reprezentujÃº text. KeÄ chceme ale dostaÅ¥ z dÃ¡t v sÃºbore nieÄo uÅ¾itoÄnÃ©, mali by
sme pouÅ¾iÅ¥ `buifio.Scanner`, ktorÃ½ nÃ¡m vie sÃºbor rozdeliÅ¥ naprÃ­klad na riadky,
Äi ÄÃ­sla:

```go
package main

import (
	"bufio"
	"fmt"
	"os"
)

func main() {
	file, err := os.Open("test.txt")
	if err != nil {
		fmt.Println("nastala chyba!")
		return
	}
	scanner := bufio.NewScanner(file) // vytvorime scanner na riadky
	scanner.Scan()                    // precitame riadok
	text := scanner.Text()            // dostaneme ho von zo scannera
	fmt.Println(text)                 // napiseme ho
}
```

StÃ¡le to vyzerÃ¡ trochu komplikovane, preÄo musÃ­me najprv otvÃ¡raÅ¥ sÃºbor a potom z
neho vytvÃ¡raÅ¥ `Scanner`? OdpoveÄ je jednoduchÃ¡: `NewScanner` berie ako argument
ÄokoÄ¾vek implementujÃºce interface `io.Reader`, ktorÃ½ mÃ¡ definovanÃ½ iba jednu
metÃ³du:

```go
type Reader interface {
  func (T) Read(b []byte) (n int, err error)
}
```

Readery majÃº mnoho vyuÅ¾itÃ­ - naprÃ­klad mÃ´Å¾eme vytvoriÅ¥ reader, ktorÃ½ text Å¡ifruje,
zapÃ­saÅ¥ jeho vÃ½stup do sÃºboru, alebo ho poslaÅ¥ cez internet, a na druhom konci
ho prehnaÅ¥ cez Reader, ktorÃ½ text deÅ¡ifruje. Rovnako praktickÃ© je pouÅ¾Ã­vanie
Readerov pre kompresiu a dekompresiu dÃ¡t.

# Å truktÃºra textu

Vieme, Å¾e vÅ¡etko v poÄÃ­taÄi sa skladÃ¡ z bytov. Ako je teda moÅ¾nÃ© - Å¾e poÄÃ­taÄe
vedia pracovaÅ¥ aj s textom? VeÄ poznajÃº iba ÄÃ­sla! OdpoveÄ je jednoduchÃ¡ - kaÅ¾dÃ©mu
pÃ­smenu priradÃ­me jedno ÄÃ­slo. Text je potom iba zoznam ÄÃ­sel, ktorÃ½ na poÄÃ­taÄi
reprezentovaÅ¥ vieme.

PrvÃ½ pokus o reprezentovanie textu bol [ASCII](https://en.wikipedia.org/wiki/ASCII) -
american standard code for information interchange, ktorÃ½ bol vytvorenÃ½ v podstate
eÅ¡te pred poÄÃ­taÄmi. Tento kÃ³d obahuje 128 znakov, ÄiÅ¾e pouÅ¾Ã­va iba 7 bitov. Okrem
vÅ¡etkÃ½ch pÃ­smen a ÄÃ­sel americkej abecedy obsahuje aj niektorÃ© kontrolnÃ© znaky, ktorÃ©
boli doslova vytvorenÃ© pre pÃ­sacie stroje: NÃ¡vrat vozÃ­ka, Posunutie riadku, zvonÄek,
posunutie pÃ¡sky s atramentom, ale najdÃ´leÅ¾itejÅ¡ia je asi nula - znak ÄÃ­slo nula
sa totiÅ¾ v mnohÃ½ch programovacÃ­ch jazykoch pouÅ¾Ã­va na ukonÄenie stringu. To, ako
Go ukonÄuje svoje stringy, vÃ´bec rieÅ¡iÅ¥ nemusÃ­me, keÄÅ¾e to pred nami skrÃ½va, ale
niektorÃ© jazyky dokonca typ `string` ani nemajÃº!

VrÃ¡Å¥me sa ale ku textu: problÃ©m s ASCII je jasnÃ½: bolo vytvorenÃ© iba pre
ameriÄanov, ktorÃ­ nemajÃº Å¾iadnu diakritiku. NaÅ¡Å¥astie, keÄÅ¾e malo iba 7 bitov,
na 8-bitovÃ½ch poÄÃ­taÄoch zaÄali inÃ© krajiny vyuÅ¾Ã­vaÅ¥ hornÃ½ch 128 bitov na rÃ´zne
Å¡peciÃ¡lne znaky. Vznikla tak kopa rÃ´znych variÃ¡nt ASCII, ktorÃ© na svete nespÃ´sobili
niÄ inÃ© ako chaos. KeÄ si to Ä¾udia koneÄne uvedomili (a microsoft si to neuvedomil dodnes),
zaviedli novÃ½ spÃ´sob kÃ³dovania pÃ­sma, ktorÃ½ ascii ponechÃ¡ tak ako je, ale hornÃ½
bit vyuÅ¾ije oveÄ¾a kreatÃ­vnejÅ¡ie: Ak sÃº dva hornÃ© bity 1 a ÄalÅ¡Ã­ nula, za bytom
nasleduje ÄalÅ¡Ã­ byte. Ak sa byte konÄÃ­ tromi jednotkami a nulou, za bytom
nasledujÃº dva ÄalÅ¡ie byty. TakÃ©to kÃ³dovanie, ktorÃ© sa volÃ¡ [UTF-8](https://en.wikipedia.org/wiki/UTF-8),
je schopnÃ© zakÃ³dovaÅ¥ aÅ¾ miliÃ³n rÃ´znych znakov. Na tom, akÃ© tie znaky budÃº, sa
inÅ¾inierom naÅ¡Å¥astie takisto podarilo dohodnÃºÅ¥ a tak vytvorili Å¡tandard [Unicode](https://en.wikipedia.org/wiki/Unicode),
ktorÃ½ obsahuje skoro vÅ¡etky abecedy sveta, kopu Å¡peciÃ¡lnych znakov, emoji,
ba dokonca aj hieroglyfy (naprÃ­klad aj hieroglyf D053 ğ“‚º), alebo celÃ© arabskÃ©
poÅ¾ehnanie bismillar hir rahman nir rahim (ï·½).

Pointa je stÃ¡le jasnÃ¡ - text je reÅ¥azec bytov, ktorÃ© buÄ samÃ© o sebe
reprezentujÃº pÃ­smeno, alebo sÃº sÃºÄasÅ¥ou jednÃ©ho zloÅ¾itejÅ¡ieho pÃ­smena. Jazyk Go
nÃ¡m dovoÄ¾uje pÃ­smenÃ¡ ukladaÅ¥ ako chceme, ale zÃ¡roveÅˆ nÃ¡m ponÃºka aj typ `rune`,
ktorÃ½ je aliasom pre 32-bitovÃ½ `int`. Teraz si ukÃ¡Å¾eme, ako sa s takÃ½mto typom
pracuje:

```go
func main() {
	text := "DobrÃ½ deÅˆ! "
	var rune_a rune = 'a' // jednoduche uvodzovky reprezentuju znak
	var rune_b rune = 65021
	text += string(rune_a)
	text += string(rune_b)
	// iterujeme cez string!
	for k, v := range text {
		// znova nam pomoze printf:
		//   %d znamena cislo
		//   %c znamena znak
		fmt.Printf("Znak %d mÃ¡ hodnotu %d a reprezentuje pÃ­smeno '%c'\n", k, v, v)
	}
}
```

# Zadanie

Vytvorte vlastnÃ½ typ implementujÃºci `io.Reader`, kotrÃ½ sa dÃ¡ vytvoriÅ¥ zo `string`u
a vracia na vÃ½stupe text zaÅ¡iforvanÃ½ Ä¾ubovoÄ¾nou Å¡ifrou. Vytvore potom ÄalÅ¡Ã­ typ,
ktorÃ½ bude schopnÃ½ tento text deÅ¡ifrovaÅ¥.
